Python Object-Oriented Programming Tasks 🐍
This repository contains a series of Python tasks focused on Object-Oriented Programming (OOP). Each file corresponds to a specific OOP concept or task.

Task List 📋
1_using_self.py 👤

2_using_cls.py 🔑

3_Public_Variables_and_Methods.py 🌐

4_Class_Variables_and_Methods.py 📦

5_Static_Variables_and_Static_Methods.py 🔋

6_Constructors_and_Destructors.py 🛠️

7_Public_Private_and_Protected.py 🔒

8_super_function.py 🚀

9_Abstract_classes_and_methods.py 🎓

10_Instance_methods.py ✅

11_Class_Methods.py ✅

12_Static_Method.py ✅

13_Composition.py 🔄

14_Aggregation.py 🔗

15_MRO.py 🔝

16_function_decorator.py 🎨

17_Class_decorators.py 🎨

18_property_setter_deleter.py 🏠

19_Callable.py 📞

20_try_except.py ⚠️

21_Custom_Class_Iterable.py 🔄

Description of Topics 📚
Instance Methods: Working with methods that belong to an instance of the class and how to access instance data.

Class Methods: Methods that operate on the class itself rather than instances, accessed via cls.

Static Methods: Methods that don’t access or modify class or instance-specific data.

Composition: The concept of building complex objects by combining simpler objects.

Aggregation: A specialized form of association where one object can exist independently but is related to another.

MRO (Method Resolution Order): How Python resolves method calls in the presence of multiple inheritance.

Function Decorators: Applying decorators to modify or enhance the behavior of functions.

Class Decorators: Using decorators to modify or enhance classes.

Property Setters and Deleters: Controlling access and manipulation of instance attributes with getter, setter, and deleter methods.

Callable Objects: Making objects behave like functions by implementing the __call__ method.

Exception Handling (try...except): Managing errors and exceptions using the try...except blocks.

Custom Iterable Classes: Creating custom classes that can be iterated using __iter__() and __next__() methods.

self and cls: Understanding how self refers to instance-specific data and cls refers to class-specific data in methods.

Public, Private, and Protected Attributes: Understanding access control for attributes and methods in Python classes.

Class Constructors and Destructors: Using __init__ to initialize objects and __del__ for cleanup.

Super Function: Using the super() function for method resolution in inheritance.

How to Run ▶️
Clone this repository to your local machine.

Open each Python file in your editor of choice.

Run the Python files to see the output of each task.

Contributing 🤝
Feel free to submit pull requests for any enhancements or improvements!

Icons Explanation:
✅: Task completed

🔄: Represents iteration (for iterable tasks)

🔗: Represents relationships (for aggregation)

🔝: Represents inheritance (for MRO)

🎨: Represents decorators (for function/class decorators)

⚠️: Represents error handling (for try-except tasks)

🏠: Represents property setters and getters

📞: Represents callable objects

🔋: Represents static variables and methods

🔒: Represents access control (public, private, protected)

🚀: Represents super function (method resolution)

🎓: Represents abstract classes
