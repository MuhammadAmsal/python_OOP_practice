Python Object-Oriented Programming Tasks ğŸ
This repository contains a series of Python tasks focused on Object-Oriented Programming (OOP). Each file corresponds to a specific OOP concept or task.

Task List ğŸ“‹
1_using_self.py ğŸ‘¤

2_using_cls.py ğŸ”‘

3_Public_Variables_and_Methods.py ğŸŒ

4_Class_Variables_and_Methods.py ğŸ“¦

5_Static_Variables_and_Static_Methods.py ğŸ”‹

6_Constructors_and_Destructors.py ğŸ› ï¸

7_Public_Private_and_Protected.py ğŸ”’

8_super_function.py ğŸš€

9_Abstract_classes_and_methods.py ğŸ“

10_Instance_methods.py âœ…

11_Class_Methods.py âœ…

12_Static_Method.py âœ…

13_Composition.py ğŸ”„

14_Aggregation.py ğŸ”—

15_MRO.py ğŸ”

16_function_decorator.py ğŸ¨

17_Class_decorators.py ğŸ¨

18_property_setter_deleter.py ğŸ 

19_Callable.py ğŸ“

20_try_except.py âš ï¸

21_Custom_Class_Iterable.py ğŸ”„

Description of Topics ğŸ“š
Instance Methods: Working with methods that belong to an instance of the class and how to access instance data.

Class Methods: Methods that operate on the class itself rather than instances, accessed via cls.

Static Methods: Methods that donâ€™t access or modify class or instance-specific data.

Composition: The concept of building complex objects by combining simpler objects.

Aggregation: A specialized form of association where one object can exist independently but is related to another.

MRO (Method Resolution Order): How Python resolves method calls in the presence of multiple inheritance.

Function Decorators: Applying decorators to modify or enhance the behavior of functions.

Class Decorators: Using decorators to modify or enhance classes.

Property Setters and Deleters: Controlling access and manipulation of instance attributes with getter, setter, and deleter methods.

Callable Objects: Making objects behave like functions by implementing the __call__ method.

Exception Handling (try...except): Managing errors and exceptions using the try...except blocks.

Custom Iterable Classes: Creating custom classes that can be iterated using __iter__() and __next__() methods.

self and cls: Understanding how self refers to instance-specific data and cls refers to class-specific data in methods.

Public, Private, and Protected Attributes: Understanding access control for attributes and methods in Python classes.

Class Constructors and Destructors: Using __init__ to initialize objects and __del__ for cleanup.

Super Function: Using the super() function for method resolution in inheritance.

How to Run â–¶ï¸
Clone this repository to your local machine.

Open each Python file in your editor of choice.

Run the Python files to see the output of each task.

Contributing ğŸ¤
Feel free to submit pull requests for any enhancements or improvements!

Icons Explanation:
âœ…: Task completed

ğŸ”„: Represents iteration (for iterable tasks)

ğŸ”—: Represents relationships (for aggregation)

ğŸ”: Represents inheritance (for MRO)

ğŸ¨: Represents decorators (for function/class decorators)

âš ï¸: Represents error handling (for try-except tasks)

ğŸ : Represents property setters and getters

ğŸ“: Represents callable objects

ğŸ”‹: Represents static variables and methods

ğŸ”’: Represents access control (public, private, protected)

ğŸš€: Represents super function (method resolution)

ğŸ“: Represents abstract classes
